# 一、集合
## 1. HashMap的数据结构
    1> 数组 + 链表
    2> jdk1.8版本及之后是: 数组 + 链表 + 红黑树
## 2. HashMap每次扩容多大?
    1> 计算HashMap是否进行扩容, 有一个称为负载因子的常量为0.75, 也就是HashMap默认容量为16, 那么达到扩容的临界值为16 * 0.75 = 12, 达到这个临界值后就会进行2倍的扩容
    2> 那临界值为原来值的0.75倍的意义: 如果太小例如0.5就进行扩容会造成一定的内存资源浪费, 如果太大例如1进行扩容会增加get或者put操作时的hash碰撞几率
## 3. ConcurrentHashMap是如何保证线程安全的
    1> jdk1.7及之前是基于分段锁(ReentrantLock可重入锁)来实现线程安全; 加锁原理: 将大数组分隔成多个小数组, 然后对这些小数组各自进行加锁和释放锁的操作
    2> jdk1.8及之后是基于CAS或者synchronized来实现线程安全, 进一步缩小了锁的粒度; 加锁原理: 如果根据存储元素计算的hash值没有冲突则采用CAS的方式来保证元素的存储安全, 如果计算的hash值发生了hash冲突则采用synchronized方式加锁来保证数据的存储安全
## 4. 采用HashSet(数据结构: 哈希表 = 数组 + 链表/红黑树)和ArrayList(数据结构: 动态数组)进行集合操作
    1> 如果是进行元素顺序新增操作, ArrayList的性能会更好, 因为HashSet在进行元素新增时需要计算hash值, 且可能发生hash碰撞, 而ArrayList是进行顺序添加的, 这就导致ArrayList会比HashSet的效率要好;
    2> 如果是进行元素索引查询, ArrayList的效率更好, 因为ArrayLisy的数据结构是数组, 所以根据索引查询效率很高, 而HashSet需要先进行hash计算然后找到对应链表或者树, 这样效率就没有ArrayList高;
    3> 如果是进行元素查询, HashSet的效率要更好, 因为ArrayList是通过循环遍历的方式进行元素查询, 而HashSet可以根据计算Hash值找到对应的链表或者树, 缩小查找的范围, 所以效率更高;
    4> 如果是进行元素删除操作, HashSet的效率要更好, 因为ArrayList是通过循环遍历先找到元素, 然后进行元素删除并调整数据结构, 而HashSet是先计算hash值, 然后找到对应的链表和树, 获取对应的元素删除并调整数据结构, 这样涉及到的数据结构调整较小, 所以效率更高;
    5> 总结:
        (1) 如果对数据量不大的集合进行集合运算, 使用ArrayList或者HashSet进行集合操作均可;
        (2) 如果对数据量较大的集合进行集合运算, 推荐使用HashSet进行集合操作;
        
# 二、SpringMVC
## 1. SpringMVC的返回响应
    1> 如果类或方法上没有标注注解@ResponseBody, 默认返回是会被视图解析器解析成视图, 如果找不到指定的视图则会报错
    2> servlet的Forward和Redirect区别: 
        (1) Forward:表示请求转发,不会改变Request,浏览器中看的地址也不会发生改变
        (2) Redirect:表示请求重定向,会改变Request,浏览器中的地址会变成重定向后的地址
        
# 注意事项: 
## 一、接口设计
    1. 接口设计时, 需要避免客户端接口和后台管理系统接口调用相同的方法, 因为一般管理系统需要查询的数据范围较大且查询条件复杂, 可能涉及到多表的关联
        查询, 而客户端的使用场景一般比较单一且也不适合过于复杂的查询, 如果共用查询方法, 客户端请求量和数据量上来后, 容易因为复杂的查询逻辑造成
        慢SQL问题, 严重可能拖垮服务造成服务不可用, 如果业务上查询比较复杂, 需要考虑使用加工宽表冗余相关字段, 以满足复杂复杂的查询场景
    2. 接口设计时, 需要考虑接口的数据安全和权限管控, 特别是客户敏感数据, 接口不必要返回的字段一定不返回, 如果返回敏感字段注意数据脱敏
    3. 接口设计时, 需要考虑查询条件相关的入参字段的交互, 避免因为交互问题而导致查询时接收的参数过于庞大, 从而导致SQL查询效率低下, 例如IN()查询语
        句,MySQL使用IN查询时尽量控制在1000个数据范围内
    4. 接口设计时, 需要注意入参的字段长度校验, 避免接收字段长度超过数据库存储长度而造成新增或更新数据异常的问题
    5. 接口设计时, 需考虑接口的限流处理, 避免因为短时间的大量请求而拖垮系统

## 二、功能设计
    1. 功能设计时, 尽量避免设计过多的标识字段用作功能逻辑上的区分, 增加系统复杂性和维度难度; 例如在设计客户身份功能时, 最好只用用户角色进行区分, 
        不要使用多重逻辑(例如: 用户角色, 用户标识), 避免进行用户功能或权限管控时, 出现交叉逻辑, 不易于维护
    2. 功能设计时, 注意性能瓶颈, 不要为了设计而设计, 平白无故增加业务功能的代码逻辑复杂度, 要始终遵从"大道至简", 要用最简单可行的代码实现即可
    3. 功能设计时, 注意控制查数据的数据量级, 以免一次查出大量的数据而导致内存溢出的问题, 如果需要查询数据过大, 一定要使用分页查询, 同时分页
        查询也要注意深分页的问题
    4. 功能设计时, 需要控制写数据的数据量级, 避免一次操作大量的数据而造成相关服务(如数据库、redis的CPU、内存、网络开销以及数据库长事务等问题)
        性能问题, 如果数据量过大需进行分批操作, 一次操作的数据控制在1000左右, 也可以根据服务实际情况进行数据量级调整
    5. 功能设计时, 在使用多线程进行数据处理时, 注意当前线程的上下文变量不影响其他线程也不要受其他线程影响, 特别要注意避免线程污染问题的发生; 在线
        程销毁前及时清理相关的变量信息; 如果使用多线程对同一变量有写操作, 一定要注意此变量的线程安全问题(要考虑加锁, 或者使用线程安全对象, 如果
        使用锁, 需要考虑锁的释放问题, 避免造成死锁)
    6. 功能设计时, 使用线程池进行数据操作时, 需要注意线程池相关参数配置, 需要考虑数据量超过线程池队列长度时的容错处理(例如在使用
        CompletableFuture框架时, 如果提交的任务操作过了线程池队列长度, 那么在调用CompletableFuture的join()方法时会导致其一直阻塞, 因为
        被线程池执行拒绝策略的任务会永远无法达到CompletableFuture的"已完成"标记状态, 而使join()方法一直处于等待所有任务完成的状态); 异步执
        行的业务逻辑, 需要注意考虑执行逻辑异常的处理; 使用多线程相关框架等待所有任务执行完成时最好设定超时处理, 避免因执行任务异常而导致阻塞问题
    7. 功能设计时, 使用锁进行业务处理时, 需要控制好锁的粒度, 避免锁的粒度过大而导致长事务问题和接口性能问题, 避免锁的粒度过小而导致锁失效的问题;
        注意锁的释放, 避免因业务逻辑异常而导致锁无法释放

## 三、表设计
    1. 表设计时, 要注意适当的字段冗余, 不要为了业务的切割, 而将不同业务相关表完全区分开, 造成查询数据的困难, 增加业务复杂度和数据库性能瓶颈
    2. 表设计时, 需要注意业务表之间关联的字段一定要统一含义和字段, 不要不同字段表达相同含义, 也不要相同的字段表达不同的含义, 增加后期维护难度
    3. 表设计时, 需要根据业务考虑表的数据增长速度, 适当建立相关字段的索引, 避免因数据增长而导致慢查询问题
    4. 表设计时, 需要根据业务考虑数据的使用期限, 如果速度增长过快, 需对有效期之外的数据进行定期迁移到备份表, 减去实时表的数据存储和查询压力, 
        如果数据在业务上都有效, 那就需要考虑分库分表设计

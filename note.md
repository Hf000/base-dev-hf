# 一、集合
## 1. HashMap的数据结构
    1> 数组 + 链表
    2> jdk1.8版本及之后是: 数组 + 链表 + 红黑树
## 2. HashMap每次扩容多大?
    1> 计算HashMap是否进行扩容, 有一个称为负载因子的常量为0.75, 也就是HashMap默认容量为16, 那么达到扩容的临界值为16 * 0.75 = 12, 达到这个临界值后就会进行2倍的扩容
    2> 那临界值为原来值的0.75倍的意义: 如果太小例如0.5就进行扩容会造成一定的内存资源浪费, 如果太大例如1进行扩容会增加get或者put操作时的hash碰撞几率
## 3. ConcurrentHashMap是如何保证线程安全的
    1> jdk1.7及之前是基于分段锁(ReentrantLock可重入锁)来实现线程安全; 加锁原理: 将大数组分隔成多个小数组, 然后对这些小数组各自进行加锁和释放锁的操作
    2> jdk1.8及之后是基于CAS或者synchronized来实现线程安全, 进一步缩小了锁的粒度; 加锁原理: 如果根据存储元素计算的hash值没有冲突则采用CAS的方式来保证元素的存储安全, 如果计算的hash值发生了hash冲突则采用synchronized方式加锁来保证数据的存储安全
## 4. 采用HashSet(数据结构: 哈希表 = 数组 + 链表/红黑树)和ArrayList(数据结构: 动态数组)进行集合操作
    1> 如果是进行元素顺序新增操作, ArrayList的性能会更好, 因为HashSet在进行元素新增时需要计算hash值, 且可能发生hash碰撞, 而ArrayList是进行顺序添加的, 这就导致ArrayList会比HashSet的效率要好;
    2> 如果是进行元素索引查询, ArrayList的效率更好, 因为ArrayLisy的数据结构是数组, 所以根据索引查询效率很高, 而HashSet需要先进行hash计算然后找到对应链表或者树, 这样效率就没有ArrayList高;
    3> 如果是进行元素查询, HashSet的效率要更好, 因为ArrayList是通过循环遍历的方式进行元素查询, 而HashSet可以根据计算Hash值找到对应的链表或者树, 缩小查找的范围, 所以效率更高;
    4> 如果是进行元素删除操作, HashSet的效率要更好, 因为ArrayList是通过循环遍历先找到元素, 然后进行元素删除并调整数据结构, 而HashSet是先计算hash值, 然后找到对应的链表和树, 获取对应的元素删除并调整数据结构, 这样涉及到的数据结构调整较小, 所以效率更高;
    5> 总结:
        (1) 如果对数据量不大的集合进行集合运算, 使用ArrayList或者HashSet进行集合操作均可;
        (2) 如果对数据量较大的集合进行集合运算, 推荐使用HashSet进行集合操作;
        
# 二、SpringMVC
## 1. SpringMVC的返回响应
    1> 如果类或方法上没有标注注解@ResponseBody, 默认返回是会被视图解析器解析成视图, 如果找不到指定的视图则会报错
    2> servlet的Forward和Redirect区别: 
        (1) Forward:表示请求转发,不会改变Request,浏览器中看的地址也不会发生改变
        (2) Redirect:表示请求重定向,会改变Request,浏览器中的地址会变成重定向后的地址
        
# 注意事项: 
## 一、接口设计
    1. 客户端接口不要和后台管理系统接口调用相同的方法, 因为一般管理系统需要查询的数据很大可能涉及到多表的关联的查询, 而客户端一般不需要, 如果共用, 请求量和数据量上来后, 客户端请求容易因为联表的查询造成慢SQL, 导致慢请求问题
    2. 接口设计时, 注意接口的数据安全和权限管控
    3. 接口设计时, 需要考虑查询条件相关的入参字段的交互, 避免因为交互问题而导致查询时接收的参数过于庞大, 从而导致SQL查询效率低下

## 二、功能设计
    1. 在设计客户身份功能时, 最好只用用户角色进行区分, 不要使用多重逻辑(例如: 用户角色, 用户标识), 避免进行用户功能或权限管控时, 出现交叉逻辑, 不易于维护
    2. 功能设计时, 注意性能瓶颈, 不要为了设计而设计, 平白无故增加业务功能的代码逻辑复杂度, 要始终遵从"大道至简", 要用最简单可行的设计实现即可
    3. 注意查询数据时, 一次查询出的数据大小, 以免一次查出大量的数据而导致内存溢出的问题    

## 三、表设计
    1. 表设计时, 要注意适当的字段冗余, 不要为了业务的切割, 而将不同业务相关表完全区分开, 造成查询数据的困难, 且要注意我们业务上表之间关联的字段一定要统一含义和字段, 不要不同字段表达相同含义
    2. 进行表设计时, 需要根据业务考虑表的数据增长速度, 适当建立相关字段的索引

# 一、集合
## 1. HashMap的数据结构
    1> 数组 + 链表
    2> jdk1.8版本及之后是: 数组 + 链表 + 红黑树
## 2. HashMap每次扩容多大?
    1> 计算HashMap是否进行扩容, 有一个称为负载因子的常量为0.75, 也就是HashMap默认容量为16, 那么达到扩容的临界值为16 * 0.75 = 12, 达到这个临界值后就会进行2倍的扩容
    2> 那临界值为原来值的0.75倍的意义: 如果太小例如0.5就进行扩容会造成一定的内存资源浪费, 如果太大例如1进行扩容会增加get或者put操作时的hash碰撞几率
## 3. ConcurrentHashMap是如何保证线程安全的
    1> jdk1.7及之前是基于分段锁(ReentrantLock可重入锁)来实现线程安全; 加锁原理: 将大数组分隔成多个小数组, 然后对这些小数组各自进行加锁和释放锁的操作
    2> jdk1.8及之后是基于CAS或者synchronized来实现线程安全, 进一步缩小了锁的粒度; 加锁原理: 如果根据存储元素计算的hash值没有冲突则采用CAS的方式来保证元素的存储安全, 如果计算的hash值发生了hash冲突则采用synchronized方式加锁来保证数据的存储安全
## 4. 采用HashSet(数据结构: 哈希表 = 数组 + 链表/红黑树)和ArrayList(数据结构: 动态数组)进行集合操作
    1> 如果是进行元素顺序新增操作, ArrayList的性能会更好, 因为HashSet在进行元素新增时需要计算hash值, 且可能发生hash碰撞, 而ArrayList是进行顺序添加的, 这就导致ArrayList会比HashSet的效率要好;
    2> 如果是进行元素索引查询, ArrayList的效率更好, 因为ArrayLisy的数据结构是数组, 所以根据索引查询效率很高, 而HashSet需要先进行hash计算然后找到对应链表或者树, 这样效率就没有ArrayList高;
    3> 如果是进行元素查询, HashSet的效率要更好, 因为ArrayList是通过循环遍历的方式进行元素查询, 而HashSet可以根据计算Hash值找到对应的链表或者树, 缩小查找的范围, 所以效率更高;
    4> 如果是进行元素删除操作, HashSet的效率要更好, 因为ArrayList是通过循环遍历先找到元素, 然后进行元素删除并调整数据结构, 而HashSet是先计算hash值, 然后找到对应的链表和树, 获取对应的元素删除并调整数据结构, 这样涉及到的数据结构调整较小, 所以效率更高;
    5> 总结:
        (1) 如果对数据量不大的集合进行集合运算, 使用ArrayList或者HashSet进行集合操作均可;
        (2) 如果对数据量较大的集合进行集合运算, 推荐使用HashSet进行集合操作;
        
# 二、SpringMVC
## 1. SpringMVC的返回响应
    1> 如果类或方法上没有标注注解@ResponseBody, 默认返回是会被视图解析器解析成视图, 如果找不到指定的视图则会报错
    2> servlet的Forward和Redirect区别: 
        (1) Forward:表示请求转发,不会改变Request,浏览器中看的地址也不会发生改变
        (2) Redirect:表示请求重定向,会改变Request,浏览器中的地址会变成重定向后的地址